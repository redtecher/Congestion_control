# Sender 端

应用层调用rdt_send方法， 将数据推送至应用层

应用层调用make_pdt将数据打包成报文段， 并在报文段中封装进一个 校验码， 和一个值为0 或 1的序号 ， 并将其存储至缓存区

应用层调用udt_send方法将打包完成的报文段推送至信道， 并启动一个定时器事件

Sender端 此时状态迁移为 等待序号为 0 或 1 报文段 的ACK应答状态

倘若在定时器等待时间内， 没有收到响应， 则重新执行第3步
# Receptor端

较低层通过rdt_rcv方法， 将数据推送到运输层

运输层接收到报文段， 对报文段数据进行校验处理， 校验成功则执行第 4 步， 校验失败则执行第 3 步

发送缓存区数据序号的确认ACK指令, 同时开启一个定时器， 保持等待下层调用的状态

检测数据序号， 如果是冗余数据， 直接丢弃数据，发送缓存区中数据序号的ACK指令，对于非冗余数据， 将数据置换到缓存区中， 发送一个对该数据序号的确认ACK指令， 同时开启一个定时器
倘若在定时器等待时间内， 没有收到响应， 则重新执行第3或第4步

# Sender端

接收到应答指令后进行数据校验处理， 如果数据校验错误， 直接重新发送上次数据， 如果正确则执行步第 2 步

判断接受到的应答指令，如果指令为ACK中的序号等于缓存区的序号，执行第 3 步， 如果ACK指令序号不等于缓存区序号则执行 4

重新发送上次数据， 状态迁移到 等待ACK， 同时开启一个定时器

Sender端不再阻塞， 可以发送新的序号值为 1 或 0 的数据， 状态迁移到 等待来自上层调用

倘若在定时器等待时间内， 没有收到响应， 则重新执行第 3或 第4步
